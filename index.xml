<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gaurolog</title><link>https://dimpu47.github.io/</link><description>Recent content on gaurolog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 02 Oct 2020 17:09:14 -0500</lastBuildDate><atom:link href="https://dimpu47.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Sniffing in Go.</title><link>https://dimpu47.github.io/blog/sniffing-in-go/</link><pubDate>Fri, 02 Oct 2020 17:09:14 -0500</pubDate><guid>https://dimpu47.github.io/blog/sniffing-in-go/</guid><description>What is sniffing ? Sniffing is a process of monitoring and capturing all data packets passing through given network. Sniffers are used by network/system administrator to monitor and troubleshoot network traffic. Attackers use sniffers to capture data packets containing sensitive information such as password, account information etc.
So, in layman terms: caputring packets from network traffic for leverage.
Wireless traffic is particularly vulnerable to sniffing because all the packets are broadcast through the air instead of through Ethernet, where physical access is required for the wire to intercept traffic.</description></item><item><title>Operators in Go or Ansible.</title><link>https://dimpu47.github.io/blog/k8s-operator/</link><pubDate>Wed, 24 Jun 2020 15:07:32 +0530</pubDate><guid>https://dimpu47.github.io/blog/k8s-operator/</guid><description>Operators makes it easy to incorporte ops knowledge in k8s native resource. They are not something new, but they way it is built, managed and implemented is revolutionary. In fundamental k8s terms an operator is CRD ( custom resource definition ) and custom Controller.
Controllers are what integrates the CRD to k8s api and database. these are what makes kubernetes pluggable and extedable, as this is way to add your custom logic in context of k8s cluster.</description></item><item><title>Extending Kubernetes</title><link>https://dimpu47.github.io/blog/extending-kubernetes/</link><pubDate>Sun, 02 Feb 2020 17:09:14 -0500</pubDate><guid>https://dimpu47.github.io/blog/extending-kubernetes/</guid><description>How would you extend k8s or why would you want to ? Answering the why is easy but hard as well. Easy, because it allows you to create custom resources in k8s, reconciliation loop to control or manage those custom resources according to your own rules and expertise on your own custom resource. Hard, because now you&amp;rsquo;ll have to think of usecases where this is suitable. For inspiration you can look at the etcd operator by coreos.</description></item><item><title>Structural Patterns in Go.</title><link>https://dimpu47.github.io/blog/facade-and-flyweight/</link><pubDate>Sun, 22 Dec 2019 17:09:14 -0500</pubDate><guid>https://dimpu47.github.io/blog/facade-and-flyweight/</guid><description>Structural design patterns describe the relationships between the entities. They are used to form large structures using classes and objects. These patterns are used to create a system with different system blocks in a flexible manner. Adapter, bridge, composite, decorator, facade, flyweight, private class data, and proxy are the Gang of Four (GoF) structural design patterns. The private class data design pattern is the other design pattern covered in this section.</description></item><item><title>Container Storage Interface</title><link>https://dimpu47.github.io/blog/storage-k8s/</link><pubDate>Thu, 12 Sep 2019 17:09:14 -0500</pubDate><guid>https://dimpu47.github.io/blog/storage-k8s/</guid><description>CSI is the container storage interface. It is a plugin for Kubernetes and other container orchestrators that allows storage suppliers to expose their products to containerised applications as persistent storage. You can look the detailed specification here.
Although prior to CSI Kubernetes provided a powerful volume plugin system, it was challenging to add support for new volume plugins to Kubernetes: volume plugins were “in-tree” meaning their code was part of the core Kubernetes code and shipped with the core Kubernetes binaries—vendors wanting to add support for their storage system to Kubernetes (or even fix a bug in an existing volume plugin) were forced to align with the Kubernetes release process.</description></item><item><title>Isomorphic Go.</title><link>https://dimpu47.github.io/blog/isomorphic-go/</link><pubDate>Sat, 19 Jan 2019 15:07:32 +0530</pubDate><guid>https://dimpu47.github.io/blog/isomorphic-go/</guid><description>Sharing is caring is a cliche but not when is comes to webapps.
Isomorphic web applications are becoming popular and accepted methodology by many in the Game. in dictionary terms, it means something of the corresponding or similar form or relations.
Hmm&amp;hellip; wth! I know&amp;hellip;
what is isomorphic, though? isomorphic webapps are when server and client share some common data with each other and thus correspond/relate to each other inorder to deliver quicker, providing better user experience, improved discovery via search engines, and reduced ops since parts of code is shared b/w both parties.</description></item><item><title>Horizontal Pod Autoscaler.</title><link>https://dimpu47.github.io/blog/k8s-hpa/</link><pubDate>Mon, 19 Nov 2018 15:07:32 +0530</pubDate><guid>https://dimpu47.github.io/blog/k8s-hpa/</guid><description>Horizontal Pod Autoscaler - HPA HorizaontalPodAutoscaler is a Kubernetes Resource that automatically scales Pod Replicas managed by a Controller. This automaic scaling is performed by Horizontal Controllers, which is enabled and configured by creating a HorizontalPodAutoscaler(HPA) Resource. The Controller periodically checks pod metrics, calculates the no. of replicas required to meet the target value configured in HPA resource and adjust/update replica field on target resource i.e. Deployment, ReplicaSet, StatefulSet, ReplicationController.</description></item><item><title>systems programming in Go.</title><link>https://dimpu47.github.io/blog/go-systems-programming/</link><pubDate>Sat, 25 Aug 2018 17:09:14 -0500</pubDate><guid>https://dimpu47.github.io/blog/go-systems-programming/</guid><description>why golang for systems programming&amp;hellip; ? .
Go was written by google as famously sited many times over the internet. Some of the people involved in development of Golang are working professionals at Google, who were also involved with many Unix &amp;amp; C developments, and they developed Golang because of increasing complex demands of System Engineering at google, and C was becoming hard to maintain.
Go&amp;rsquo;s concurrency model is built upon CSP - Communicating Sequencial Processes Where values are shared b/w independent activities or goroutines but variables are, for the most part, confined to single activity.</description></item><item><title>websockets in Go.</title><link>https://dimpu47.github.io/blog/go-websockets/</link><pubDate>Mon, 25 Jun 2018 17:09:14 -0500</pubDate><guid>https://dimpu47.github.io/blog/go-websockets/</guid><description>Websockets are way of providing full-duplex communication b/w client and server with lower overheads. URI schemes ws or wss is a websocket (unencrypted) or websocket secure (encrypted) protocol respectively. It&amp;rsquo;s designed to work over HTTP port 80 or 443 to support HTTP Proxies and Intermediaries.
When establishing connection, client sends an HTTP Upgrade Header to switch from HTTP protocol to WebSocket protocol. Communications i.e. exchange of data or byte streams are dealt by TCP alone.</description></item><item><title>Oops! not have go installed ? Woah o_O</title><link>https://dimpu47.github.io/code/code/</link><pubDate>Sat, 17 Dec 2016 15:32:33 +0530</pubDate><guid>https://dimpu47.github.io/code/code/</guid><description> compile from source ? not really !</description></item></channel></rss>